using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.Events;

public class GameManager : MonoBehaviour
{
    [Header("Game Settings")]
    [SerializeField] private float cardFlipDuration = 0.5f;
    [SerializeField] private float cardMatchDelay = 1f;
    
    [Header("Events")]
    public UnityEvent<int> onMovesCountChanged;
    public UnityEvent onGameWon;

    [SerializeField] private GameBoardGenerator boardGenerator;
    
    private List<Card> cards = new List<Card>();
    private List<Card> flippedCards = new List<Card>();
    private int movesCount;
    private bool isProcessingMatch;
    
    private void Awake()
    {
        if (boardGenerator != null)
            boardGenerator.OnBoardGenerated += SubscribeToCards;
    }
    
    private void Start()
    {
        // If the board has already been generated by this point, you can subscribe immediately
        SubscribeToCards();
    }
    
    private void OnDestroy()
    {
        if (boardGenerator != null)
            boardGenerator.OnBoardGenerated -= SubscribeToCards;

        foreach (var card in cards)
        {
            if (card != null)
                card.OnCardClicked -= HandleCardClick;
        }
    }
    
    private void SubscribeToCards()
    {
        cards = FindObjectsOfType<Card>().ToList();
        foreach (var card in cards)
        {
            card.OnCardClicked -= HandleCardClick;
            card.OnCardClicked += HandleCardClick;
            card.ShowFront();
        }
        StartCoroutine(HideAllCardsAfterDelay(3f));
    }
    
    private System.Collections.IEnumerator HideAllCardsAfterDelay(float delay)
    {
        yield return new WaitForSeconds(delay);
        foreach (var card in cards)
        {
            if (!card.IsMatched)
                card.ShowBack();
        }
    }
    
    public void HandleCardClick(Card clickedCard)
    {
        if (isProcessingMatch || flippedCards.Contains(clickedCard) || clickedCard.IsMatched)
            return;
            
        clickedCard.Flip();
        flippedCards.Add(clickedCard);
        
        if (flippedCards.Count == 2)
        {
            movesCount++;
            onMovesCountChanged?.Invoke(movesCount);
            
            StartCoroutine(CheckForMatch());
        }
    }
    
    private System.Collections.IEnumerator CheckForMatch()
    {
        isProcessingMatch = true;
        
        // Wait for the second card to finish flipping
        yield return new WaitForSeconds(cardFlipDuration);
        
        Card firstCard = flippedCards[0];
        Card secondCard = flippedCards[1];
        
        if (firstCard.CardId == secondCard.CardId)
        {
            // Match found
            firstCard.SetMatched();
            secondCard.SetMatched();
            
            yield return new WaitForSeconds(cardMatchDelay);
            firstCard.Hide();
            secondCard.Hide();
            
            if (cards.All(card => card.IsMatched))
            {
                yield return new WaitForSeconds(cardMatchDelay);
                onGameWon?.Invoke();
            }
        }
        else
        {
            // No match, flip cards back
            yield return new WaitForSeconds(cardMatchDelay);
            firstCard.Flip();
            secondCard.Flip();
        }
        
        flippedCards.Clear();
        isProcessingMatch = false;
    }
    
    public void ResetGame()
    {
        movesCount = 0;
        onMovesCountChanged?.Invoke(movesCount);
        flippedCards.Clear();
        isProcessingMatch = false;
        
        foreach (var card in cards)
        {
            card.Reset();
        }
    }
} 